# 基于Reactor模式的高并发服务器

## 项目介绍
本项目使用C++语言开发了一个高并发服务器，基于Reactor模式构建，利用 `epoll` 进行事件管理，以实现高效的网络 I/O 操作。该服务器适合处理大量的并发连接请求，能够稳定运行并响应多个客户端的请求。项目设计简洁，便于扩展和维护，适用于构建高性能的网络服务器。

## 项目原理

### epoll的原理
`epoll` 是Linux下的高性能I/O多路复用模型，通过 `epoll`，可以监控大量的文件描述符事件（如读、写、异常等），一旦有事件发生，epoll 会通知应用程序处理相应的 I/O 操作。epoll 主要包含三个系统调用：
1. `epoll_create()`：创建一个 epoll 实例。
2. `epoll_ctl()`：向 epoll 实例中添加、删除或修改文件描述符。
3. `epoll_wait()`：等待事件发生，返回已触发的文件描述符集合。

### Reactor架构
Reactor 模式是一种事件驱动的处理架构，将事件监听和事件处理解耦，适合处理高并发需求。Reactor模式中的关键组件包括：
- **事件分发器**：负责监听事件（如 I/O 事件）并触发相应的处理。
- **事件处理器**：根据事件类型和状态，执行特定的处理逻辑。
- **资源管理器**：管理所需的资源（如网络连接和线程）以实现高效调度。

在本项目中，Reactor 模式利用 epoll 实现事件的监听和分发，通过独立的事件处理器处理不同类型的网络请求，确保了并发情况下服务器的稳定和响应速度。
### 多线程的主从Reactor模型
- 单线程的Reactor模型不能发挥多核CPU的性能
- 运行多个事件循环，主事件循环运行在主线程中，从事件循环运行在线程池中
- 主线程负责创建客户端链接，然后将connection分配给线程池处理
### 子线程事件循环和业务处理的分离
如果某个子线程需要处理的业务数据复杂，那么子线程会长时间阻塞在业务处理代码上，相当于该子线程无法继续事件循环承担分配连接的任务，所以要再创建一系列的工作线程来分担子线程的业务处理工作

更新之后的模型，相当于Accepter中监听客户端的传入连接事件，accept到链接之后交给子线程管理，每个子线程都有各自的事件循环和各自的epoll红黑树来承载和客户的连接，时刻监听客户的请求，客户的请求到达之后，子线程再将对请求的处理分配给工作线程，工作线程处理完客户的数据之后再将处理后的数据写入输出缓冲区，子线程在监听读事件的同时也在监听写事件，一旦写就绪就可以将写缓冲区的数据发送出去。这样就能实现非常高效的并发业务处理

但是依然有一个问题，就是如果所有工作线程都被占满了，而子线程又不能处理业务数据，那么有可能业务处理请求会积压在子线程对工作线程的请求处理队列中无法被分配出去，此时的优化方向要么是增加动态增长工作线程数的机制，要么在业务方面优化，让业务处理的时间缩短。

#### 具体实现思路
由于业务处理最终回调到了上层业务类的processCallBack函数中，

## 项目结构
```
project-root
├── bin             # 可执行文件目录
├── build           # 编译生成的文件
├── etc             # 日志输出配置文件
├── include         # 项目所需头文件
├── log             # 运行过程中产生的日志文件
├── scripts         # 编译脚本和运行脚本
│   └── build.sh    # 编译脚本
└── src             # 源代码文件
    ├── main.cpp    # 主程序文件
    └── impl        # 头文件对应的实现文件
```

## 如何运行项目
1. 首先运行编译脚本：
   ```bash
   ./scripts/build.sh
   ```
2. 编译完成后，执行 bin 目录中的可执行文件启动服务器：
   ```bash
   ./bin/epollserver
   ```
